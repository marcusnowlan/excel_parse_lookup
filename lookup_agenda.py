# -*- coding: utf-8 -*-
"""lookup_agenda

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1R_s-_duHLGz0AoS6WysO42-oFCbIvoF_
"""

# lookup_agenda
# Looks up the specified column title and expected value (specified in the
# second and third arguments in the command line, respectively), and prints out
# the information (in column title : value format) of every session that matches
# the expected value (in the specified column), as well as the information of
# every subsession of the matching sessions.
import sys
import xlrd
import sqlite3
sys.path.append(".")
from db_table import db_table

# Parses the command line to get the specified column title and expected value:
col = sys.argv[1]
val = sys.argv[2]

# Accesses the database created in import_agenda:
agenda_table = db_table("agenda", {"date" : "text", "time_start" : "text", 
                               "time_end" : "text", 
                               "session_or_subsession" : "text", 
                               "title" : "text", "location" : "text",
                               "description" : "text", "speaker" : "text",
                               "sub_of_date" : "text", "sub_of_time" : "text",
                               "sub_of_title" : "text", 
                               "sub_of_location" : "text"})

# First, fill the result with the information of every session that matches
# the expected value in the specified column:
result = agenda_table.select(["date", "time_start", "time_end", 
                              "session_or_subsession", "title", "location", 
                              "description", "speaker"], {col : val})

# If the search column is 'speaker', a new process must be done to get each
# matching session's info, since multiple speakers may be in one data cell.
if col == 'speaker':
  # First, result must be reset so that there are no repeats (the first
  # assignment to result will add all sessions where the expected value is the 
  # sole speaker):
  result = []
  # For each entry in the database, create a list of the speakers for the event,
  # and add the event information to the result if one of the speakers is the 
  # expected value:
  for entry in agenda_table.select(["date", "time_start", "time_end", 
                              "session_or_subsession", "title", "location", 
                              "description", "speaker"]):
    speakers = entry["speaker"].split("; ")
    if val in speakers:
      result.append(entry)    

# Then, for each session that matched (regardless if the specified column was 
# 'speaker' or not), use its date, start time, title, and 
# location to find all of its subsessions (as each subsession has this
# information in its last 4 columns), and append the information of these
# subsessions to the result:
for res in result:
  result.extend(agenda_table.select(["date", "time_start", "time_end", 
                                     "session_or_subsession", "title", 
                                     "location", "description", "speaker"], 
                                    {"sub_of_date" : res["date"], 
                                     "sub_of_time" : res["time_start"], 
                                     "sub_of_title" : res["title"],
                                     "sub_of_location" : res["location"]}))

# Finally, print the result to the console:
print(result)